import { z } from 'zod';
import {
  authorFlairRichTextSchema,
  awardingSchema,
  banInfoSchema,
  crowdControlLevelSchema,
  distinguishTypeSchema,
  gildingsSchema,
  linkFlairV2Schema,
  mediaEmbedSchema,
  userFlairV2Schema,
} from './index';

export const mediaRedditVideoSchema = z.object({
  bitrateKbps: z.number().optional().describe('The bitrate of the video in kbps.'),
  dashUrl: z.string().optional().describe('The URL of the DASH manifest.'),
  duration: z.number().optional().describe('The duration of the video in seconds.'),
  fallbackUrl: z.string().optional().describe('A fallback URL for the video.'),
  height: z.number().optional().describe('The height of the video.'),
  hlsUrl: z.string().optional().describe('The URL of the HLS manifest.'),
  isGif: z.boolean().optional().describe('Whether the video is a GIF.'),
  scrubberMediaUrl: z.string().optional().describe('The URL of the scrubber media.'),
  transcodingStatus: z.string().optional().describe('The status of the video transcoding.'),
  width: z.number().optional().describe('The width of the video.'),
}).describe('Schema for a Reddit-hosted video within a media object.');

export const mediaSchema = z.object({
  redditVideo: mediaRedditVideoSchema.optional().describe('A Reddit-hosted video.'),
}).describe('Schema for media content in a post.');

export const previewPreviewImageSchema = z.object({
  id: z.string().optional().describe('The ID of the preview image.'),
  source: z.string().optional().describe('The source URL of the preview image.'),
  resolutions: z.array(z.string()).describe('A list of resolutions for the preview image.'),
  variants: z.record(z.any()).optional().describe('Variants of the preview image.'),
}).describe('Schema for a single preview image in a post preview.');

export const previewSchema = z.object({
  enabled: z.boolean().optional().describe('Whether previews are enabled for the post.'),
  images: z.array(previewPreviewImageSchema).describe('A list of preview images.'),
}).describe('Schema for the preview of a post.');

export const redditVideoSchema = z.object({
  bitrateKbps: z.number().describe('The bitrate of the video in kbps.'),
  fallbackUrl: z.string().describe('A fallback URL for the video.'),
  height: z.number().describe('The height of the video.'),
  width: z.number().describe('The width of the video.'),
  scrubberMediaUrl: z.string().describe('The URL of the scrubber media.'),
  dashUrl: z.string().describe('The URL of the DASH manifest.'),
  duration: z.number().describe('The duration of the video in seconds.'),
  hlsUrl: z.string().describe('The URL of the HLS manifest.'),
  isGif: z.boolean().describe('Whether the video is a GIF.'),
  transcodingStatus: z.string().describe('The status of the video transcoding.'),
}).describe('Schema for a Reddit-hosted video.');

export const oembedSchema = z.object({
  type: z.string().describe('The type of the oEmbed content.'),
  version: z.string().describe('The version of the oEmbed content.'),
  title: z.string().describe('The title of the oEmbed content.'),
  description: z.string().describe('The description of the oEmbed content.'),
  authorName: z.string().describe('The name of the author of the oEmbed content.'),
  authorUrl: z.string().describe('The URL of the author\'s profile.'),
  providerName: z.string().describe('The name of the oEmbed provider.'),
  providerUrl: z.string().describe('The URL of the oEmbed provider.'),
  thumbnailUrl: z.string().describe('The URL of the thumbnail.'),
  thumbnailWidth: z.number().describe('The width of the thumbnail.'),
  thumbnailHeight: z.number().describe('The height of the thumbnail.'),
  html: z.string().describe('The HTML of the oEmbed content.'),
  width: z.number().describe('The width of the oEmbed content.'),
  height: z.number().describe('The height of the oEmbed content.'),
}).describe('Schema for oEmbed content in a post.');

export const redditPostGallerySchema = z.object({
  items: z.array(z.string()).describe('A list of gallery item IDs.'),
}).describe('Schema for a Reddit post gallery.');

export const postSchema = z.object({
  allAwardings: z.array(awardingSchema).describe('A list of all awards on this post.'),
  allowLiveComments: z.boolean().optional().describe('Whether live comments are allowed.'),
  approved: z.boolean().optional().describe('Whether the post is approved.'),
  approvedAtUtc: z.number().optional().describe('The UTC timestamp of when the post was approved.'),
  approvedBy: z.string().optional().describe('The user who approved the post.'),
  archived: z.boolean().optional().describe('Whether the post is archived.'),
  author: z.string().optional().describe('The author of the post.'),
  authorFlairBackgroundColor: z.string().optional().describe('The background color of the author\'s flair.'),
  authorFlairCssClass: z.string().optional().describe('The CSS class of the author\'s flair.'),
  authorFlairRichtext: z.array(authorFlairRichTextSchema).describe('The rich text of the author\'s flair.'),
  authorFlairTemplateId: z.string().optional().describe('The template ID of the author\'s flair.'),
  authorFlairText: z.string().optional().describe('The text of the author\'s flair.'),
  authorFlairTextColor: z.string().optional().describe('The text color of the author\'s flair.'),
  authorFlairType: z.string().optional().describe('The type of the author\'s flair.'),
  authorFullname: z.string().optional().describe('The fullname of the author.'),
  authorIsBlocked: z.boolean().optional().describe('Whether the author is blocked by the current user.'),
  authorPatreonFlair: z.boolean().optional().describe('Whether the author has Patreon flair.'),
  authorPremium: z.boolean().optional().describe('Whether the author has Reddit Premium.'),
  awarders: z.array(z.string()).describe('A list of users who awarded the post.'),
  bannedAtUtc: z.number().optional().describe('The UTC timestamp of when the author was banned.'),
  bannedBy: z.string().optional().describe('The user who banned the author.'),
  canGild: z.boolean().optional().describe('Whether the post can be gilded.'),
  canModPost: z.boolean().optional().describe('Whether the current user can moderate the post.'),
  category: z.string().optional().describe('The category of the post.'),
  clicked: z.boolean().optional().describe('Whether the post has been clicked by the current user.'),
  contentCategories: z.array(z.string()).describe('A list of content categories.'),
  contestMode: z.boolean().optional().describe('Whether the post is in contest mode.'),
  created: z.number().optional().describe('The timestamp of when the post was created.'),
  createdUtc: z.number().optional().describe('The UTC timestamp of when the post was created.'),
  discussionType: z.string().optional().describe('The type of discussion.'),
  distinguished: z.string().optional().describe('How the post is distinguished (e.g., "moderator").'),
  domain: z.string().optional().describe('The domain of the link.'),
  downs: z.number().optional().describe('The number of downvotes.'),
  edited: z.boolean().optional().describe('Whether the post has been edited.'),
  gilded: z.number().optional().describe('The number of times the post has been gilded.'),
  gildings: gildingsSchema.optional().describe('The gildings for the post.'),
  hidden: z.boolean().optional().describe('Whether the post is hidden by the current user.'),
  hideScore: z.boolean().optional().describe('Whether the score is hidden.'),
  id: z.string().optional().describe('The ID of the post.'),
  isCreatedFromAdsUi: z.boolean().optional().describe('Whether the post was created from the ads UI.'),
  isCrosspostable: z.boolean().optional().describe('Whether the post is crosspostable.'),
  isMeta: z.boolean().optional().describe('Whether the post is a meta post.'),
  isOriginalContent: z.boolean().optional().describe('Whether the post is marked as original content.'),
  isRedditMediaDomain: z.boolean().optional().describe('Whether the post is from a Reddit media domain.'),
  isRobotIndexable: z.boolean().optional().describe('Whether the post is indexable by robots.'),
  isSelf: z.boolean().optional().describe('Whether the post is a self-post.'),
  isSponsored: z.boolean().optional().describe('Whether the post is sponsored.'),
  isVide: z.boolean().optional().describe('Whether the post is a video.'),
  likes: z.boolean().optional().describe('Whether the current user has liked the post.'),
  linkFlairBackgroundColor: z.string().optional().describe('The background color of the link flair.'),
  linkFlairCssClass: z.string().optional().describe('The CSS class of the link flair.'),
  linkFlairRichtext: z.array(z.string()).describe('The rich text of the link flair.'),
  linkFlairTextColor: z.string().optional().describe('The text color of the link flair.'),
  linkFlairText: z.string().optional().describe('The text of the link flair.'),
  linkFlairType: z.string().optional().describe('The type of the link flair.'),
  locked: z.boolean().optional().describe('Whether the post is locked.'),
  mediaEmbed: mediaEmbedSchema.optional().describe('Embedded media for the post.'),
  mediaOnly: z.boolean().optional().describe('Whether the post is media-only.'),
  media: mediaSchema.optional().describe('Media content of the post.'),
  modNote: z.string().optional().describe('A note from a moderator.'),
  modReasonBy: z.string().optional().describe('The user who provided the moderator reason.'),
  modReasonTitle: z.string().optional().describe('The title of the moderator reason.'),
  modReports: z.array(z.array(z.any())).describe('Moderator reports on the post.'),
  name: z.string().optional().describe('The fullname of the post.'),
  noFollow: z.boolean().optional().describe('Whether to apply "nofollow" to links in the post.'),
  numComments: z.number().optional().describe('The number of comments on the post.'),
  numCrossposts: z.number().optional().describe('The number of crossposts.'),
  numDuplicates: z.number().optional().describe('The number of duplicate posts.'),
  numReports: z.number().optional().describe('The number of reports on the post.'),
  over18: z.boolean().optional().describe('Whether the post is marked as NSFW.'),
  parentWhitelistStatus: z.string().optional().describe('The whitelist status of the parent.'),
  permalink: z.string().optional().describe('The permalink of the post.'),
  pinned: z.boolean().optional().describe('Whether the post is pinned.'),
  postHint: z.string().optional().describe('A hint for the type of post.'),
  preview: previewSchema.optional().describe('The preview of the post.'),
  pwls: z.number().optional().describe('Parent whitelist status (numerical).'),
  quarantine: z.boolean().optional().describe('Whether the post is quarantined.'),
  removalReason: z.string().optional().describe('The reason for the post\'s removal.'),
  removedByCategory: z.string().optional().describe('The category of the removal.'),
  removedBy: z.string().optional().describe('The user who removed the post.'),
  removed: z.boolean().optional().describe('Whether the post was removed.'),
  reportReasons: z.array(z.string()).describe('A list of reasons for reports.'),
  rteMode: z.string().optional().describe('The rich text editor mode used.'),
  saved: z.boolean().optional().describe('Whether the post is saved by the current user.'),
  score: z.number().optional().describe('The score of the post.'),
  secureMediaEmbed: mediaEmbedSchema.optional().describe('Secure embedded media for the post.'),
  secureMedia: mediaSchema.optional().describe('Secure media content of the post.'),
  selftextHtml: z.string().optional().describe('The HTML representation of the self-text.'),
  selftext: z.string().optional().describe('The self-text of the post as markdown.'),
  sendReplies: z.boolean().optional().describe('Whether the author wants to receive replies.'),
  spam: z.boolean().optional().describe('Whether the post is marked as spam.'),
  spoiler: z.boolean().optional().describe('Whether the post is marked as a spoiler.'),
  stickied: z.boolean().optional().describe('Whether the post is stickied.'),
  subredditId: z.string().optional().describe('The ID of the subreddit.'),
  subredditNamePrefixed: z.string().optional().describe('The prefixed name of the subreddit (e.g., "r/pics").'),
  subredditSubscribers: z.number().optional().describe('The number of subscribers to the subreddit.'),
  subredditType: z.string().optional().describe('The type of the subreddit.'),
  subreddit: z.string().optional().describe('The subreddit the post belongs to.'),
  suggestedSort: z.string().optional().describe('The suggested sort for comments.'),
  thumbnailHeight: z.number().optional().describe('The height of the thumbnail.'),
  thumbnailWidth: z.number().optional().describe('The width of the thumbnail.'),
  thumbnail: z.string().optional().describe('The URL of the thumbnail.'),
  title: z.string().optional().describe('The title of the post.'),
  topAwardedType: z.string().optional().describe('The type of the top award.'),
  totalAwardsReceived: z.number().optional().describe('The total number of awards received.'),
  treatmentTags: z.array(z.string()).describe('A list of treatment tags.'),
  ups: z.number().optional().describe('The number of upvotes.'),
  upvoteRatio: z.number().optional().describe('The ratio of upvotes to downvotes.'),
  urlOverriddenByDest: z.string().optional().describe('The URL overridden by the destination.'),
  url: z.string().optional().describe('The URL of the post.'),
  userReports: z.array(z.array(z.any())).describe('User reports on the post.'),
  viewCount: z.number().optional().describe('The number of views.'),
  visited: z.boolean().optional().describe('Whether the post has been visited by the current user.'),
  whitelistStatus: z.string().optional().describe('The whitelist status.'),
  wls: z.number().optional().describe('Whitelist status (numerical).'),
  linkFlairTemplateId: z.string().optional().describe('The template ID of the link flair.'),
  crowdControlLevel: z.number().optional().describe('The crowd control level of the post.'),
  isGallery: z.boolean().optional().describe('Whether the post is a gallery.'),
  isLiveStream: z.boolean().optional().describe('Whether the post is a live stream.'),
  isMetaDiscussion: z.boolean().optional().describe('Whether the post is a meta discussion.'),
  oembed: oembedSchema.optional().describe('oEmbed content for the post.'),
  banInfo: banInfoSchema.optional().describe('Information about a ban related to this post.'),
  markedSpam: z.boolean().optional().describe('PRIVATE: Whether the post is marked as spam.'),
  verdict: z.string().optional().describe('The verdict on the post.'),
  gallery: redditPostGallerySchema.optional().describe('The gallery content of the post.'),
}).describe('Schema for a Reddit post (legacy).');

export const postV2Schema = z.object({
  id: z.string().describe('The ID of the post.'),
  title: z.string().describe('The title of the post.'),
  selftext: z.string().describe('The self-text of the post as markdown.'),
  nsfw: z.boolean().describe('Whether the post is marked as NSFW.'),
  authorId: z.string().describe('The ID of the author.'),
  crowdControlLevel: crowdControlLevelSchema.describe('The crowd control level of the post.'),
  numReports: z.number().describe('The number of reports on the post.'),
  isGallery: z.boolean().describe('Whether the post is a gallery.'),
  isMeta: z.boolean().describe('Whether the post is a meta post.'),
  createdAt: z.number().describe('The UTC timestamp of when the post was created.'),
  isApproved: z.boolean().describe('Whether the post is approved.'),
  isArchived: z.boolean().describe('Whether the post is archived.'),
  distinguished: distinguishTypeSchema.describe('How the post is distinguished.'),
  ignoreReports: z.boolean().describe('Whether reports on the post are ignored.'),
  isSelf: z.boolean().describe('Whether the post is a self-post.'),
  isVideo: z.boolean().describe('Whether the post contains a video.'),
  isLocked: z.boolean().describe('Whether the post is locked.'),
  isSpoiler: z.boolean().describe('Whether the post is marked as a spoiler.'),
  subredditId: z.string().describe('The ID of the subreddit.'),
  upvotes: z.number().describe('The number of upvotes.'),
  downvotes: z.number().describe('The number of downvotes.'),
  url: z.string().describe('The URL of the post.'),
  isSticky: z.boolean().describe('Whether the post is stickied.'),
  linkFlair: linkFlairV2Schema.optional().describe('The link flair of the post.'),
  authorFlair: userFlairV2Schema.optional().describe('The author flair of the post.'),
  spam: z.boolean().describe('Whether the post is marked as spam.'),
  deleted: z.boolean().describe('Whether the post was deleted.'),
  languageCode: z.string().describe('The language code of the post.'),
  updatedAt: z.number().describe('The UTC timestamp of when the post was last updated.'),
  gildings: z.number().describe('The number of gildings on the post.'),
  score: z.number().describe('The score of the post.'),
  numComments: z.number().describe('The number of comments on the post.'),
  thumbnail: z.string().describe('The URL of the thumbnail.'),
  media: z.record(z.any()).optional().describe('Media content of the post.'),
  crosspostParentId: z.string().describe('The ID of the parent post if crossposted.'),
  permalink: z.string().describe('The permalink of the post.'),
  isPoll: z.boolean().describe('Whether the post is a poll.'),
  isPromoted: z.boolean().describe('Whether the post is promoted.'),
  isMultiMedia: z.boolean().describe('Whether the post contains multiple media items.'),
  type: z.string().describe('The type of the post.'),
  unlisted: z.boolean().describe('Whether the post is unlisted.'),
  galleryImages: z.array(z.string()).describe('A list of gallery image URLs.'),
  isImage: z.boolean().describe('Whether the post is a single image.'),
}).describe('Schema for a Reddit post (V2).'); 