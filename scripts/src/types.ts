import { z } from 'zod';
import fs from 'fs';
import path from 'path';

export const ReadMeObject = z.object({
  path: z
    .string()
    .startsWith('https://')
    .describe(
      'The complete path to the README file in the package or outside the package',
    ),
  type: z
    .enum(['main', 'constructor', 'functionality'])
    .describe('The type of the README file'),
  extension: z
    .enum(['md', 'txt', 'html'])
    .describe('The extension of the README file'),
  functionality: z
    .string()
    .optional()
    .describe('The functionality this README file explains on how to use'),
  description: z
    .string()
    .optional()
    .describe(
      'The description of the functionality this README file explains on how to use',
    ),
});

export const Instructions = z.object({
  type: z.enum(['video', 'image', 'externalLink']),
  url: z.string().url(),
  placement: z.enum(['onCopy', 'onHowToGet']).optional(),
});

export const KeyInfo = z.object({
  key: z.string().describe('The key of the constructor'),
  displayName: z.string().describe('The display name of the key'),
  description: z.string().describe('The description of the key'),
  defaultValue: z
    .string()
    .or(z.array(z.string()))
    .or(z.number())
    .or(z.array(z.number()))
    .or(z.boolean())
    .optional()
    .describe('The default value of the key'),
  instructions: Instructions.optional(),
});

export const KeyInfoWithUi = KeyInfo.extend({
  ui: z.object({
    type: z.enum([
      'text',
      'number',
      'boolean',
      'select',
      'multiSelect',
      'textarea',
      'image',
      'autogeneratedToken',
    ]),
    options: z
      .array(z.object({ label: z.string(), value: z.string() }))
      .optional(),
    placeholder: z.string().optional(),
    label: z.string().optional(),
    required: z.boolean().optional(),
    isPrefilled: z.boolean().optional(),
    isUnique: z.boolean().optional(),
    disabled: z.boolean().optional(),
  }),
});

export const Constructor = z
  .object({
    name: z.string().describe('The name of the constructor'),
    description: z.string().describe('The description of the constructor'),
    docUrl: z.string().url().optional(),
    auth: z
      .enum(['oauth2', 'apikey', 'none'])
      .describe('The authentication method of the constructor'),
    authEndpoint: z
      .string()
      .optional()
      .describe('The endpoint to authenticate the user with our app'),
    webhookEndpoint: z
      .string()
      .optional()
      .describe('The webhook endpoint to receive events from the platform'),
    requiredKeys: z
      .array(KeyInfo)
      .describe('The required keys of the constructor'),
    isAutoSetupEnabled: z.boolean().optional(),
    requiredKeysInstructions: Instructions.optional(),
    requiredKeysComponent: z.string().optional(),
    internalKeys: z
      .array(KeyInfo)
      .describe('The oauth2 keys of the constructor'),
    functionalities: z
      .array(z.string())
      .default([])
      .describe('The functionalities of the constructor'),
    botConfig: z
      .array(KeyInfoWithUi)
      .default([])
      .describe('The bot config of the constructor'),
    botConfigInstructions: Instructions.optional(),
    botConfigComponent: z.string().optional(),
    apiType: z
      .enum(['bot_token', 'api_key'])
      .optional()
      .describe('The type of the API'),
  })
  .refine(
    data => {
      // If auth is 'apikey', apiType must be provided
      if (data.auth === 'apikey') {
        return data.apiType !== undefined;
      }
      return true;
    },
    {
      message: "apiType is required when auth is 'apikey'",
      path: ['apiType'],
    },
  );

export type Constructor = z.infer<typeof Constructor>;

export const PackageInfo = z
  .object({
    name: z
      .string()
      .describe('The name of the package - @slack/web-api or @microfox/slack'),
    title: z.string().describe('Display name of the package'),
    platformType: z
      .enum(['communication', 'tool', 'agent', 'internal'])
      .default('communication')
      .describe('The platform type of the package'),
    authEndpoint: z.string().optional(),
    webhookEndpoint: z.string().optional(),
    authType: z.enum(['oauth2', 'apikey', 'none']).optional(),
    oauth2Scopes: z.array(z.string()).optional(),
    description: z.string().describe('One line Description of the package'),
    path: z
      .string()
      .describe(
        'The path to the package in the monorepo - packages/@ext_@slack#web-api or packages/slack',
      )
      .refine(
        value =>
          value.startsWith('packages/@ext_') || value.startsWith('packages/'),
        {
          message:
            'Path must start with either "packages/@ext_" or "packages/"',
        },
      ),
    addedDependencies: z
      .array(z.string())
      .optional()
      .describe('The added dependencies of the package'),
    dependencies: z
      .array(z.string())
      .describe('The dependencies of the package'),
    status: z
      .enum([
        'stable',
        'external',
        'semiStable',
        'unstable',
        'oauthConnector',
        'webhookConnector',
        'internal',
      ])
      .describe('The status of the package'),
    documentation: z.string().describe('The documentation of the package'),
    icon: z
      .string()
      .describe('The icon url of the package')
      .startsWith('https://'),
    constructors: z.array(Constructor),
    keyInstructions: z
      .object({
        link: z.string().url(),
        setupInfo: z.string().optional(),
      })
      .optional(),
    extraInfo: z.array(z.string()),
  })
  .refine(
    data => {
      // If all_readmes is not provided, validation passes
      if (data.status === 'external') {
        // data.path must start with packages/ext_
        if (!data.path.startsWith('packages/@ext_')) {
          return false;
        }
      }
      if (data.status === 'stable') {
        // data.path must start with packages/@microfox
        if (data.path.startsWith('packages/@ext_')) {
          return false;
        }
      }
      return true;
    },
    {
      message: `The path of the package must start with packages/@ext_ for external packages and packages/ for stable packages`,
      path: ['path'],
    },
  )
  .refine(
    data => {
      if (data.status !== 'stable' && data.status !== 'external') return true;
      // If the icon is a GitHub raw URL from our repository
      if (
        data.icon.includes('raw.githubusercontent.com/microfox-ai/microfox')
      ) {
        try {
          // Extract the path after the repository name
          const pathInRepo = data.icon.split('microfox/refs/heads/main/')[1];
          if (!pathInRepo) return false;

          // Resolve the path relative to the workspace root
          const workspaceRoot = path.resolve(__dirname, '..', '..');
          const localPath = path.join(workspaceRoot, pathInRepo);

          return fs.existsSync(localPath);
        } catch (error) {
          return false;
        }
      }
      // For external URLs, just validate that it's a valid HTTPS URL
      return data.icon.startsWith('https://');
    },
    {
      message: `The icon must be either a valid HTTPS URL or a valid path to an existing file in the repository`,
      path: ['icon'],
    },
  );

export type PackageInfo = z.infer<typeof PackageInfo>;
