import Anthropic from "@anthropic-ai/sdk";
import { DeclarativeTemplate, DeclarativeTemplateSchema, WordEntry } from "../schemas";
import { LayoutElement } from "./tailwind-generator";

const tailwindDefaultTheme = {
  fontSize: {
    'xs': '0.75rem', 'sm': '0.875rem', 'base': '1rem', 'lg': '1.125rem', 'xl': '1.25rem',
    '2xl': '1.5rem', '3xl': '1.875rem', '4xl': '2.25rem', '5xl': '3rem', '6xl': '3.75rem',
    '7xl': '4.5rem', '8xl': '6rem', '9xl': '8rem',
  },
  fontWeight: {
    'thin': '100', 'extralight': '200', 'light': '300', 'normal': '400',
    'medium': '500', 'semibold': '600', 'bold': '700', 'extrabold': '800', 'black': '900',
  },
  colors: {
    'transparent': 'transparent', 'current': 'currentColor', 'white': '#ffffff',
    'black': '#000000', 'blue-400': '#60a5fa', 'purple-500': '#a855f7',
    'yellow-400': '#facc15', 'orange-500': '#f97316',
  },
  animation: {
    'fade-in': 'fade-in 0.5s ease-in-out',
    'fade-in-up': 'fade-in-up 0.5s ease-in-out',
    'fade-in-down': 'fade-in-down 0.5s ease-in-out',
    'jump-in': 'jump-in 0.5s ease-in-out',
  }
};

const systemPrompt = `
  You are an expert in kinetic typography and graphic design, tasked with generating a declarative JSON layout for a sentence using Tailwind CSS.
  Your task is to generate a creative, visually appealing layout that emphasizes a specific "focus word".

  You MUST return ONLY a valid JSON object that adheres to the Zod schema provided below.
  Do not include any other text or explanations in your response.

  **Zod Schema:**
  ${JSON.stringify(DeclarativeTemplateSchema.shape, null, 2)}

  ---
  **TAILWIND THEME REFERENCE:**
  Use the following JSON object as your reference for available Tailwind CSS classes.
  You should only use class names that can be derived from this theme object (e.g., 'text-lg', 'font-bold', 'from-blue-400', 'animate-fade-in-up').

  ${JSON.stringify(tailwindDefaultTheme, null, 2)}
  ---

  **RULES & BEST PRACTICES:**
  1.  **Reading Order is Critical**: The final visual arrangement of text MUST follow a logical reading order (left-to-right, top-to-bottom).
  2.  **Use Placeholders**: Use the exact placeholders: \`BEFORE_FOCUS\`, \`PROMINENT_WORD\`, and \`AFTER_FOCUS\`. The \`PROMINENT_WORD\` must be visually dominant.
  3.  **Gradients**: For gradient text, you must combine multiple classes: e.g., \`bg-gradient-to-r from-blue-400 to-purple-500 text-transparent bg-clip-text\`.
  4.  **Animations**: Apply animation classes (\`animate-*\`) only to container elements, not individual words, for a cohesive effect.
`;

/**
 * Parses a Tailwind CSS font-size class and returns a numeric value for comparison.
 */
function parseTailwindFontSize(className: string): number {
  const sizeMap: { [key: string]: number } = {
    'text-xs': 1, 'text-sm': 2, 'text-base': 3, 'text-lg': 4, 'text-xl': 5,
    'text-2xl': 6, 'text-3xl': 7, 'text-4xl': 8, 'text-5xl': 9,
    'text-6xl': 10, 'text-7xl': 11, 'text-8xl': 12, 'text-9xl': 13
  };
  for (const key in sizeMap) {
    if (className.includes(key)) return sizeMap[key];
  }
  const remMatch = className.match(/text-\[(\d+(\.\d+)?)rem\]/);
  if (remMatch) {
    return parseFloat(remMatch[1]) * 10; // rem values are significantly larger
  }
  return 0;
}

/**
 * Validates the AI-generated layout to ensure it meets our quality standards.
 * @param template The template generated by the AI.
 * @throws An error if the layout is invalid.
 */
function validateAILayout(template: DeclarativeTemplate) {
  let prominentNodeSize = -1;
  let maxOtherNodeSize = -1;
  let prominentNodeFound = false;

  function traverse(node: any) {
    if (node.type === 'word') {
      const fontSize = parseTailwindFontSize(node.className || "");
      if (node.content === 'PROMINENT_WORD') {
        prominentNodeSize = fontSize;
        prominentNodeFound = true;
      } else if (node.content === 'BEFORE_FOCUS' || node.content === 'AFTER_FOCUS') {
        if (fontSize > maxOtherNodeSize) {
          maxOtherNodeSize = fontSize;
        }
      }
    }
    if (node.children) {
      node.children.forEach(traverse);
    }
  }

  traverse(template.root);

  if (!prominentNodeFound) {
    throw new Error("Validation failed: The 'PROMINENT_WORD' placeholder is missing from the template.");
  }

  if (prominentNodeSize <= maxOtherNodeSize) {
    throw new Error(`Validation failed: Prominent word size (${prominentNodeSize}) is not greater than other word sizes (${maxOtherNodeSize}).`);
  }

  console.log("âœ… AI Layout validated successfully.");
}


/**
 * Generates a layout template by calling the Anthropic Claude API, with validation and retries.
 * @param sentence - The full sentence to be laid out.
 * @param focusWord - The specific word in the sentence to emphasize.
 * @returns A promise that resolves to a DeclarativeTemplate.
 */
export async function generateTemplateFromText(
  sentence: string,
  focusWord: string,
  apiKey: string
): Promise<DeclarativeTemplate> {
  console.log("Requesting AI-generated layout from Claude for:", { sentence, focusWord });
  // Initialize the Anthropic client with the API key from environment variables
  const anthropic = new Anthropic({
    apiKey: apiKey || process.env.ANTHROPIC_API_KEY,
    // Note: Unlike OpenAI, browser use is often handled by proxying
    // or a server-side endpoint rather than a direct flag.
  });
  let lastError: Error | null = null;
  for (let i = 0; i < 3; i++) { // Try up to 3 times
    try {
      const response = await anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 2048,
        temperature: 0.7,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: `Sentence: "${sentence}"\nFocus Word to Emphasize: "${focusWord}"`,
          },
        ],
      });

      const jsonResponse = response.content[0]?.type === 'text' ? response.content[0].text : null;
      if (!jsonResponse) {
        throw new Error("AI response was empty or in an unexpected format.");
      }

      console.log(`--- Raw AI Response (Attempt ${i + 1}) ---`);
      console.log(jsonResponse);

      // Clean the response by removing markdown fences if they exist
      const cleanedResponse = jsonResponse.replace(/```json\n|```/g, '').trim();

      const parsedTemplate = JSON.parse(cleanedResponse);
      const validationResult = DeclarativeTemplateSchema.safeParse(parsedTemplate);

      if (!validationResult.success) {
        throw new Error(`AI-generated template is invalid Zod schema: ${validationResult.error.message}`);
      }

      validateAILayout(validationResult.data);

      console.log("Successfully validated AI-generated template.");
      return validationResult.data;

    } catch (error) {
      console.warn(`Attempt ${i + 1} failed:`, error);
      lastError = error as Error;
    }
  }

  console.error("Error generating AI layout after multiple attempts:", lastError);
  throw new Error(`Failed to generate a valid layout from AI after 3 attempts. Last error: ${lastError?.message}`);
} 

export function enrichLayoutWithTimings(layoutNode: LayoutElement, words: WordEntry[]): LayoutElement {
  let wordIndex = 0;

  function traverse(node: LayoutElement): LayoutElement {
    if (node.type === 'word' && node.content) {
      const nodeWords = node.content.split(/\s+/).filter(Boolean);
      if (nodeWords.length > 1) {
        // This node contains multiple words, so we use reduce to build an array of valid new children.
        const newChildren = nodeWords.reduce((acc: LayoutElement[], wordText: string) => {
          const wordData = words[wordIndex];
          if (wordData && wordData.word.toLowerCase() === wordText.toLowerCase()) {
            acc.push({
              id: `${node.id}-${wordData.word}-${wordIndex}`,
              type: 'word' as const,
              content: wordData.word,
              className: '',
              style: {},
              children: [],
              startTime: wordData.startTime,
              endTime: wordData.endTime,
            });
          } else {
            console.warn(`Mismatch or index out of bounds: layout word "${wordText}", caption word "${wordData?.word}"`);
          }
          wordIndex++;
          return acc;
        }, []);
        
        // Return a container with the new word children
        return { ...node, children: newChildren, content: undefined };

      } else if (nodeWords.length === 1) {
        // This node contains a single word.
        const wordData = words[wordIndex];
        if (wordData && wordData.word.toLowerCase() === nodeWords[0].toLowerCase()) {
            wordIndex++;
            return {
                ...node,
                startTime: wordData.startTime,
                endTime: wordData.endTime
            };
        }
      }
    }

    // If it's a container or a word node we couldn't process, recurse on children.
    return {
      ...node,
      children: node.children.map(traverse),
    };
  }
  return traverse(layoutNode);
}