---
title: 'Agents & Agent Handlers'
sidebarTitle: 'Defining Agents'
description: 'Learn about agents, execution context, path definitions, and agent-to-agent communication.'
---

## What are Agents?

Agents are the primary handlers in your AI Router application. They are async functions that receive a context object and can interact with users, call other agents, or be exposed as tools for LLM integration. With the new **agent-as-tools** pattern, agents form the core of your AI application's logic and decision-making capabilities.

```typescript
router.agent('/path', async (ctx) => {
  // Agent logic here
  return { message: 'Hello from agent!' };
});
```

## Path Definitions

Paths in AI Router follow a hierarchical structure similar to web routing. They can be static or dynamic:

### Static Paths

```typescript
router.agent('/dashboard', async (ctx) => {
  // Handle dashboard requests
  return { dashboard: 'Welcome to the dashboard' };
});

router.agent('/api/users', async (ctx) => {
  // Handle user API requests
  return { users: ['user1', 'user2', 'user3'] };
});
```

### Dynamic Paths with Parameters

Paths can include dynamic parameters using `:paramName` syntax:

```typescript
router.agent('/users/:userId', async (ctx) => {
  const { userId } = ctx.request.params;
  return { user: { id: userId, name: `User ${userId}` } };
});

router.agent('/posts/:postId/comments/:commentId', async (ctx) => {
  const { postId, commentId } = ctx.request.params;
  return {
    post: { id: postId },
    comment: { id: commentId, content: 'Comment content' },
  };
});
```

### Path Resolution

When calling agents, paths are resolved relative to the current agent's path:

```typescript
router.agent('/parent', async (ctx) => {
  // Call a sibling agent
  const siblingResult = await ctx.next.callAgent('/sibling', { data: 'hello' });

  // Call a child agent
  const childResult = await ctx.next.callAgent('child', { data: 'hello' });

  // Call an absolute path from root
  const rootResult = await ctx.next.callAgent('/@/root-agent', {
    data: 'hello',
  });

  return {
    sibling: siblingResult.data,
    child: childResult.data,
    root: rootResult.data,
  };
});
```

## Agent-to-Agent Communication

Agents can call other agents using the `ctx.next.callAgent()` method. This enables complex workflows and delegation of tasks.

### Basic Agent Calls

```typescript
router.agent('/orchestrator', async (ctx) => {
  // Call another agent and wait for result
  const result = await ctx.next.callAgent('/worker', { task: 'process-data' });

  if (result.ok) {
    return { message: `Result: ${result.data}` };
  } else {
    ctx.logger.error('Worker failed:', result.error);
    return { error: 'Worker failed', details: result.error.message };
  }
});

router.agent('/worker', async (ctx) => {
  const { task } = ctx.request.params;
  return { processed: `Processed: ${task}` };
});
```

### Chaining Multiple Agents

```typescript
router.agent('/workflow', async (ctx) => {
  // Step 1: Validate input
  const validation = await ctx.next.callAgent('/validate', ctx.request.params);
  if (!validation.ok) {
    return { error: 'Validation failed', details: validation.error.message };
  }

  // Step 2: Process data
  const processing = await ctx.next.callAgent('/process', validation.data, {
    // to stream the agent's response as tool part to the UI
    // useful & works if the agent is exposed as a tool using [.actAsTool()](/ai-router/foundation/agent-as-tool)
    stremstreamToUI: true,
  });
  if (!processing.ok) {
    return { error: 'Processing failed', details: processing.error.message };
  }

  // Step 3: Generate response
  const response = await ctx.next.callAgent('/generate', processing.data);
  return {
    result: response.data,
    workflow: 'completed',
    steps: ['validated', 'processed', 'generated'],
  };
});
```

### Attaching Agents as Tools

```typescript
router.agent('/orchestrator', async (ctx) => {
  const stream = streamText({
    model: openai('gpt-4'),
    prompt: `Write a blog post about ${topic}.`,
    tools: {
      ...ctx.next.agentAsTool('/worker'),
    },
  });
  return stream;
});
```

## Execution Context

The **execution context** is an internal system that tracks the current execution state of your AI application. It's automatically managed by the router and provides crucial information about:

- **Current Path**: The path of the agent currently being executed
- **Call Depth**: How deep the agent-to-agent call chain is (prevents infinite loops)
- **Handler Path Stack**: A stack of all handler paths in the current execution chain

```typescript
router.agent('/debug', async (ctx) => {
  // Access execution context information
  const currentPath = ctx.executionContext.currentPath;
  const callDepth = ctx.executionContext.callDepth;
  const pathStack = ctx.executionContext.handlerPathStack;

  ctx.logger.log(`Executing at path: ${currentPath}, depth: ${callDepth}`);

  return {
    debug: {
      currentPath,
      callDepth,
      pathStack,
      requestId: ctx.requestId,
    },
  };
});
```

### Call Depth Protection

The router automatically prevents infinite loops by tracking call depth. When an agent calls another agent, the call depth increases. If it exceeds the configured maximum (default: 10), the router throws a `MaxCallDepthExceededError`.

```typescript
const router = new AiRouter();
router.options.maxCallDepth = 5; // Customize maximum call depth
```

## How Parameters are Handled

Understanding how data flows into your agents is key. `ai-router` provides two main ways to pass parameters:

1.  **Initial Request**: When you first call `router.handle(path, context)`, any properties in the request body (besides `messages`) are treated as potential parameters. If an agent on the matched path is exposed as a tool (using `.actAsTool()`) with an `inputSchema`, the router will validate the request body against that schema and make the parsed parameters available in `ctx.request.params`.

2.  **Agent-to-Agent Calls**: When one agent calls another using `ctx.next.callAgent(path, params)`, the `params` object is passed directly to the next agent and becomes available in its context at `ctx.request.params`.

This mechanism allows for type-safe and validated data transfer throughout your entire agentic system.

### Example

These are parameters extracted from the URL path or passed during agent-to-agent calls:

```typescript
router.agent('/users/:userId/profile/:section', async (ctx) => {
  // Parameter from request body
  const { chatSessionId } = ctx.request;

  // Parameters from URL path
  const { userId, section } = ctx.request.params;

  // Parameters from agent call
  const { customData } = ctx.request.params;

  return {
    user: { id: userId },
    section,
    sessionId: chatSessionId,
    customData,
    message: `User ${userId}, section ${section}, data: ${customData}`,
  };
});
```

## Next Steps

- Learn about [Agent-as-Tools](/ai-router/foundation/agent-as-tool) to expose agents as tools for LLM integration
- Explore [State Management](/ai-router/foundation/state) for shared data across agents
- Understand [Middleware](/ai-router/foundation/middleware) for cross-cutting concerns
- See [Advanced Routing](/ai-router/advanced/routing) for complex scenarios
- Check [Error Handling](/ai-router/advanced/error-handling) for robust applications
- Review [Best Practices](/ai-router/advanced/best-practices) for building robust applications
