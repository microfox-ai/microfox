---
title: 'Core Principles'
description: 'Understand the design philosophy behind ai-router.'
---

The design of `ai-router` is guided by a set of core principles tailored for building advanced, multi-agent systems.

### 1. Hierarchical Routing & Depth Control

Much like Express, `ai-router` allows you to define routes for different agents and tools. This enables **agent-to-agent communication**, where one agent can call another as part of its workflow.

Routes can be dynamic, using path parameters (`/users/:id`) to create flexible and reusable agents that behave differently based on the input.

To prevent uncontrolled recursion or infinite loops in these complex interactions, the router implements **Call Depth Protection**, allowing you to configure a maximum call depth.

```typescript
// An orchestrator agent calls a worker with a dynamic parameter
router.agent('/orchestrator', async (ctx) => {
  const result = await ctx.next.callAgent('/worker/process-data');
  ctx.response.write({ type: 'text', text: `Worker says: ${result.data}` });
});

// The worker agent uses the dynamic parameter from its path
router.agent('/worker/:task', async (ctx) => {
  const { task } = ctx.request.params;
  return `Completed task: ${task}`;
});
```

### 2. Powerful Middleware

Middleware functions are at the heart of `ai-router`'s flexibility. These are functions that run before your agent handlers, giving you powerful hooks to modify the context or perform cross-cutting operations. This is incredibly useful for:

- **Authentication & Authorization**: Checking permissions before an agent can run.
- **Dynamic Context Injection**: Fetching data from a database, like a user's chat history, and injecting it into the agent's context.
- **Dynamic Tool Creation**: Attaching specific tools to an agent based on the user's session or permissions.
- **Logging & Analytics**: Tracing requests as they move through the agentic system.

```typescript
// Middleware to fetch a user's chat history from a database
const historyMiddleware = async (ctx, next) => {
  const sessionId = ctx.request.headers['x-session-id'];
  const history = await db.getHistory(sessionId);

  // Prepend the history to the current request's messages
  ctx.request.messages = [...history, ...ctx.request.messages];
  await next();
};

// Apply this middleware to all agent routes
router.use('*', historyMiddleware);
```

### 3. Advanced State Management

In a multi-agent system, you often need to pass information between agents. Passing this data through LLM tool parameters is inefficient and costly, as it consumes valuable tokens.

`ai-router` includes a `state` object in its context, similar to the `context` in Express.js. This allows you to pass data between agents and middleware on the backend without ever exposing it to the LLM. It's the perfect solution for token optimization and efficient inter-agent communication.

```typescript
router.agent('/', async (ctx) => {
  const stream = streamText({
    model: openai('gpt-4'),
    prompt: `Write a blog post about ${topic}.`,
    tools: {
      ...ctx.next.agentAsTool('/agent-1'),
      ...ctx.next.agentAsTool('/agent-2'),
    },
  });
});

router.agent('/agent-1', async (ctx) => {
  ctx.state.topic = 'LONG RESEARCH INFORMATION';
  // only return the action keeping the orchestration token usage very low.
  return { action: 'done' };
});

router.agent('/agent-2', async (ctx) => {
  // access the value from the state even though the orchestrator does not know about it.
  const { topic } = ctx.request.state;
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Write a blog post about ${topic}.`,
  });
});
```

### 4. Resumability & Human-in-the-Loop

In many agentic workflows, a process may need to pause and wait for human approval before proceeding (Human-in-the-Loop). This often happens deep within a chain of agent-to-agent calls.

Resuming such a workflow at the exact point it was paused is a complex task. `ai-router` is designed to simplify this by maintaining the execution context, making it possible to resume a deeply nested operation with the correct state and context.

```typescript
// 1. A middleware that resumes to a certain point if there is a resumable path.
// When the user confirms an action, the frontend sends a new request including the `resumePath`.
// This middleware intercepts that path and resumes the operation, bypassing the normal execution flow.
router.use('/', async (ctx, next) => {
  if (ctx.request.resumePath) {
    // If there's a resume path, call the agent and stop further execution in this chain.
    return ctx.next.callAgent(ctx.request.resumePath);
  }
  // Otherwise, continue to the next handler in the chain.
  await next();
});

// 2. An agent determines it needs human approval for a transaction
router.agent('/financial-transaction', async (ctx) => {
  const { amount, recipient } = ctx.request.params;

  // Signal to the UI that confirmation is needed by sending a tool-call
  ctx.response.write({
    type: 'tool-call',
    toolName: 'confirmTransaction',
    toolCallId: generateId(),
    args: { amount, recipient, resumePath: '/financial-transaction' },
  });
});
```

### 5. Composable & Reusable Agents

An agent should be a reusable component. With `ai-router`, any agent can be exposed and attached as a tool to another agent. For example, you can create a highly specialized `/web-research` agent once and then provide it as a tool to any other agent that needs to perform research, promoting code reuse and modularity.

```typescript
import { z } from 'zod';
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai'; // or your preferred provider

// 1. Define a reusable "research" agent and expose it as a tool
router
  .actAsTool('/research', {
    id: 'research',
    description: 'Performs web research on a specific topic.',
    inputSchema: z.object({ query: z.string() }),
    outputSchema: z.object({ summary: z.string() }),
    metadata: {
      icon: '🔍',
      title: 'Research',
    },
  })
  .agent('/research', async (ctx) => {
    const summary = await researchService.search(ctx.request.params.query);
    return { summary };
  });

// 2. Use that agent as a tool within another agent
router.agent('/blog-writer', async (ctx) => {
  const { topic } = ctx.request.params;
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Write a blog post about ${topic}.`,
    tools: {
      // Attach the existing agent as a tool for the LLM to use
      ...ctx.next.agentAsTool('/research'),
    },
  });
  ctx.response.write({ type: 'text', text });
});
```
