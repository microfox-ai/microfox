---
title: 'Structuring Applications'
description: 'Learn how to structure complex, multi-agent systems for maintainability and scalability.'
---

When building large-scale, multi-agent systems, a well-organized file structure is crucial for maintainability and scalability. We recommend a modular approach, separating your AI logic from your Next.js route handlers.

Here's a recommended project structure:

```
src/
├── ai/
│   ├── agents/
│   │   ├── code-generator/
│   │   │   ├── sub-agents/
│   │   │   │   └── code-validator/
│   │   │   │       ├── tools/
│   │   │   │       │   └── validation.tool.ts
│   │   │   │       ├── handler.ts
│   │   │   │       └── index.ts
│   │   │   ├── middleware/
│   │   │   │   └── input-validation.middleware.ts
│   │   │   ├── tools/
│   │   │   │   └── filesystem.tool.ts
│   │   │   ├── handler.ts
│   │   │   └── index.ts
│   │   └── receptionist/
│   │       ├── handler.ts
│   │       └── index.ts
│   ├── middleware/
│   │   ├── auth.middleware.ts
│   │   └── logging.middleware.ts
│   ├── tools/
│   │   └── web-search.tool.ts
│   └── router.ts
└── app/
    └── api/
        └── v1/
            └── [[...slug]]/
                └── route.ts
```

#### 1. The Main Router (`src/ai/router.ts`)

This file is the entry point for your AI system. It creates the main `AiRouter`, applies global middleware and tools, and mounts all the top-level agents.

```typescript
// src/ai/router.ts
import { AiRouter } from '@microfox/ai-router';
import { loggingMiddleware } from './middleware/logging.middleware';
import { webSearchTool } from './tools/web-search.tool';
import { receptionistAgent } from './agents/receptionist';
import { codeGeneratorAgent } from './agents/code-generator';

const appRouter = new AiRouter();

// Apply global middleware
appRouter.use('*', loggingMiddleware);

// Register global tools
appRouter.tool('/search', webSearchTool);

// Mount top-level agents
appRouter.use('/receptionist', receptionistAgent);
appRouter.use('/code', codeGeneratorAgent);

export default appRouter;
```

#### 2. Agents (`src/ai/agents/`)

Each agent is a self-contained module with its own router, handlers, tools, and even sub-agents.

**Example: A top-level agent (`src/ai/agents/code-generator/index.ts`)**

This file defines the agent's router, registers its specific tools and middleware, and sets up its main handler. It can also mount sub-agents.

```typescript
// src/ai/agents/code-generator/index.ts
import { AiRouter } from '@microfox/ai-router';
import { codeGeneratorHandler } from './handler';
import { fileSystemTool } from './tools/filesystem.tool';
import { codeValidatorAgent } from './sub-agents/code-validator';
import { inputValidationMiddleware } from './middleware/input-validation.middleware';
import { z } from 'zod';

export const codeGeneratorAgent = new AiRouter();

// Agent-specific middleware
codeGeneratorAgent.use('*', inputValidationMiddleware);

// Agent-specific tools
codeGeneratorAgent.tool('/fs', fileSystemTool);

// Agent's main handler
codeGeneratorAgent
  .actAsTool('/', {
    description: 'Generates code based on requirements',
    inputSchema: z.object({
      requirements: z.string().describe('The user requirements for the code'),
    }),
  })
  .agent('/', codeGeneratorHandler);

// Mount sub-agents
codeGeneratorAgent.use('/validator', codeValidatorAgent);
```

**Example: A sub-agent (`src/ai/agents/code-generator/sub-agents/code-validator/index.ts`)**

Sub-agents follow the same pattern, allowing you to create a hierarchy of specialized agents.

```typescript
// src/ai/agents/code-generator/sub-agents/code-validator/index.ts
import { AiRouter } from '@microfox/ai-router';
import { validationTool } from './tools/validation.tool';
import { codeValidatorHandler } from './handler';

export const codeValidatorAgent = new AiRouter();

codeValidatorAgent.tool('/validate', validationTool);
codeValidatorAgent.agent('/', codeValidatorHandler);
```

#### 3. Next.js Route Handler (`src/app/api/v1/[[...slug]]/route.ts`)

Your Next.js API route becomes extremely simple. It just imports the main router and uses it to handle requests. This keeps your API layer thin and decoupled from the AI logic.

```typescript
// src/app/api/v1/[[...slug]]/route.ts
import appRouter from '@/ai/router';

export async function POST(
  request: Request,
  { params }: { params: { slug: string[] } },
) {
  const path = `/${(params.slug || []).join('/')}`;
  const body = await request.json();
  const { messages, ...restOfBody } = body;

  const response = appRouter.handle(path, {
    request: {
      ...restOfBody,
      messages: messages || [],
    },
  });

  return response;
}
```

By following this structure, you can build complex, maintainable, and scalable multi-agent systems with `@microfox/ai-router`.
