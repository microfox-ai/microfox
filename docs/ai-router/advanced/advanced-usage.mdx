---
title: 'Advanced Usage'
description: 'Explore advanced features for building complex multi-agent systems.'
---

### Agent-to-Agent Communication

Agents can call other agents using the `next` object:

```typescript
router.agent('/orchestrator', async (ctx) => {
  // Call another agent
  const result = await ctx.next.callAgent('/worker', { task: 'process-data' });

  if (result.ok) {
    ctx.response.write({ type: 'text', text: `Result: ${result.data}` });
  }
});

router.agent('/worker', async (ctx) => {
  const { task } = ctx.request.params;
  return `Processed: ${task}`;
});
```

#### Calling Parent/Sibling Agents from Sub-Agents

When working with nested routers (sub-agents), you might need to call an agent outside of the current router's scope (e.g., a sibling or parent agent). To do this, you can use an absolute path starting with `@/`. This tells the router to resolve the path from the root of the entire application, rather than relative to the current agent's path.

```typescript
// In a sub-agent mounted at /code-generator/validator
router.agent('/', async (ctx) => {
  // ... some logic
  // Call the receptionist agent, which is mounted at the root level
  await ctx.next.callAgent('@/receptionist', { task: 'new task' });
});
```

### Using Agents as Tools

Agents can be exposed as tools for LLM function calling:

```typescript
// Define the code generator agent as a tool at /code-generator
router.actAsTool('/code-generator', {
  description: 'Generates code based on requirements',
  inputSchema: z.object({
    requirements: z.string().describe('Code requirements'),
  }),
});

// The actual agent implementation when the registeres tool is called.
router.agent('/code-generator', async (ctx) => {
  const { requirements } = ctx.request.params;

  // Generate code using an LLM
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Generate code for: ${requirements}`,
    tools: {
      // Expose other agents as tools
      analyzer: ctx.next.agentAsTool('/code-analyzer'),
      validator: ctx.next.agentAsTool('/code-validator'),
    },
  });

  ctx.response.write({ type: 'text', text });
});
```

### Dynamic Path Parameters

Support for dynamic routing with parameter extraction:

```typescript
router.agent('/users/:userId/profile', async (ctx) => {
  const { userId } = ctx.request.params;
  ctx.response.write({
    type: 'text',
    text: `Loading profile for user: ${userId}`,
  });
});
```

### Error Handling

The router provides structured error handling:

```typescript
router.agent('/protected', async (ctx) => {
  try {
    // Your agent logic
    const result = await riskyOperation();
    ctx.response.write({ type: 'text', text: result });
  } catch (error) {
    ctx.logger.error('Agent error:', error);
    ctx.response.write({
      type: 'text',
      text: 'An error occurred while processing your request.',
    });
  }
});
```
